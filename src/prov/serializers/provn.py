from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

__author__ = 'Trung Dong Huynh'
__email__ = 'trungdong@donggiang.com'
__contributor__ = 'Marcel Parciak'

import io
import logging
logger = logging.getLogger(__name__)

# import needed antlr4 elements, CommonTokenStream will tokenize the input PROV-N document
from antlr4 import CommonTokenStream
# ParseTreeWalker allows to walk through the parsed tokens
from antlr4 import ParseTreeWalker
# InputStream is needed to transform the input stream from BytesIO to a InputStream explicitly
from antlr4 import InputStream

from prov.model import ProvDocument
from prov.serializers import Serializer

# imports for automatically generated classes from antlr
from prov.serializers.antlr_grammars.PROV_NListener import PROV_NListener
from prov.serializers.antlr_grammars.PROV_NParser import PROV_NParser
from prov.serializers.antlr_grammars.PROV_NLexer import PROV_NLexer

# codecs is used to generate a utf-8 string from bytesIO inputs
import codecs
# TODO: used for debug outputs, remove at the end
from pprint import pprint
import pdb

class ProvNAntlrListener(PROV_NListener):
    """
    An extension of the automatically generated PROV_NListener, based
    on the PROV-N antlr4 grammar provided by @TomasKulhanek on GitHub
    `PROV-N grammar <https://github.com/antlr/grammars-v4/blob/master/prov-n/examples/example4.provn>`_

    For the most part, the class overrides methods automatically
    generated by antlr4 in PROV_NListener.py

    """

    def __init__(self):
        self._doc = None

    @property
    def document(self):
        return self._doc

    def iriToUri(iri):
        """Converts an iri to an uri String. This method enables
        handling iri-references from antlr at a central point.

        :param iri: The IRI to transform
        """
        return iri.getText()[1:-1]

    def getIdentifierFromContext(self, ctx):
        """Retrieves an identifier from an IdentifierContext.
        This method will check which identifier element is
        populated and parse it to a String representation
        suitable to be used as an identifier to create 
        prov elements.

        :param ctx: IdentifierContext which will be used.
        """
        if ctx.PREFX() is not None:
            return ctx.PREFX().getText()
        if ctx.QUALIFIED_NAME() is not None:
            return ctx.QUALIFIED_NAME().getText()

        # TODO: is this possible? If so, how to handle?
        # first solution: return None
        return None

    def stripExtraQuotes(string):
        if string[:1] == "'" and string[-1:] == "'":
            return string[1:-1]
        if string[:1] == '"' and string[-1:] == '"':
            return string[1:-1]
        return string

    def addAttributesToStatement(self, stmt, ctx:PROV_NParser.OptionalAttributeValuePairsContext):
        """Adds optional attributes to a statement.
        
        :param stmt: The statement the optional attributes will be added to.
        :param ctx: The context that holds the optional attributes for stmt.
        """
        if ctx.attributeValuePairs() is not None:
            for attr in ctx.attributeValuePairs().attributeValuePair():
                dire = {attr.attribute().getText(): ProvNAntlrListener.stripExtraQuotes(attr.literal().getText())}
                stmt.add_attributes(dire)

    def getValueFromContext(self, ctx):
        """Retrieves an value notation from a Context.
        This method will check which value notation is
        populated and parse it to a String representation
        suitable to be used as an value for attributes.

        :param ctx: LiteralContext which will be used.
        """
        if ctx.typedLiteral() is not None:
            return '"{}" %% {}'.format(ctx.typedLiteral().STRING_LITERAL(), self.getIdentifierFromContext(ctx.typedLiteral().datatype()))
        if ctx.convenienceNotation() is not None:
            convNot = ctx.convenienceNotation()
            if convNot.STRING_LITERAL() is not None:
                string = convNot.STRING_LITERAL().getText()
                if convNot.LANGTAG() is not None:
                    return '"{}"@{}'.format(string, convNot.LANGTAG())
                return '"{}"'.format(convNot.STRING_LITERAL())
            if convNot.INT_LITERAL() is not None:
                return convNot.INT_LITERAL().getText()
            if convNot.QUALIFIED_NAME_LITERAL() is not None:
                return convNot.QUALIFIED_NAME_LITERAL().getText()
            return None

        # if not value is given, return None
        return None

    def enterDocument(self, ctx):
        self._doc = ProvDocument()

    def enterDefaultNamespaceDeclaration(self, ctx):
        self._doc.set_default_namespace(ProvNAntlrListener.iriToUri(ctx.IRI_REF()))

    def enterNamespaceDeclaration(self, ctx):
        self._doc.add_namespace(ctx.PREFX().getText(), ProvNAntlrListener.iriToUri(ctx.namespace().IRI_REF()))

    def enterEntityExpression(self, ctx):
        ent = self._doc.entity(self.getIdentifierFromContext(ctx.identifier()))
        self.addAttributesToStatement(ent, ctx.optionalAttributeValuePairs())

class ProvNSerializer(Serializer):
    """PROV-N serializer for ProvDocument

    """
    def serialize(self, stream, **kwargs):
        """
        Serializes a :class:`prov.model.ProvDocument` instance to a
        `PROV-N <http://www.w3.org/TR/prov-n/>`_.

        :param stream: Where to save the output.
        """
        provn_content = self.document.get_provn()
        if isinstance(stream, io.BytesIO):
            provn_content = provn_content.encode('utf-8')
        stream.write(provn_content)

    def deserialize(self, stream, **kwargs):
        """
        Deserializes from a `PROV-N <https://www.w3.org/TR/prov-n/>`_
        representation to a :class:`~prov.model.ProvDocument` instance.

        :param stream: Input data.
        """
        if isinstance(stream, io.BytesIO):
            stream = codecs.decode(stream.getvalue(), encoding='utf-8')
            stream = InputStream(stream)
        if isinstance(stream, io.StringIO):
            stream = InputStream(stream.getvalue())
        lexer = PROV_NLexer(stream)
        tokenStream = CommonTokenStream(lexer)
        parser = PROV_NParser(tokenStream)
        tree = parser.document()
        listener = ProvNAntlrListener()
        walker = ParseTreeWalker()
        walker.walk(listener, tree)
        return listener.document
        #raise NotImplementedError
