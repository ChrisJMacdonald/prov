from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

__author__ = 'Trung Dong Huynh'
__email__ = 'trungdong@donggiang.com'
__contributor__ = 'Marcel Parciak'

import io
import logging
logger = logging.getLogger(__name__)

# import needed antlr4 elements, CommonTokenStream will tokenize the input PROV-N document
from antlr4 import CommonTokenStream
# ParseTreeWalker allows to walk through the parsed tokens
from antlr4 import ParseTreeWalker
# InputStream is needed to transform the input stream from BytesIO to a InputStream explicitly
from antlr4 import InputStream

from prov.model import ProvDocument
from prov.serializers import Serializer
from prov.constants import (
    PROV, PROV_ID_ATTRIBUTES_MAP, PROV_N_MAP, PROV_BASE_CLS, XSD_QNAME, PROV_ENTITY,
    PROV_END, PROV_START, PROV_USAGE, PROV_GENERATION, PROV_DERIVATION, PROV_INVALIDATION,
    PROV_ALTERNATE, PROV_MENTION, PROV_DELEGATION, PROV_ACTIVITY, PROV_ATTR_STARTTIME,
    PROV_ATTR_ENDTIME, PROV_LOCATION, PROV_ATTR_TIME, PROV_ROLE, PROV_COMMUNICATION,
    PROV_ATTR_INFORMANT, PROV_ATTR_RESPONSIBLE, PROV_ATTR_TRIGGER, PROV_ATTR_ENDER,
    PROV_ATTR_STARTER, PROV_ATTR_USED_ENTITY, PROV_ASSOCIATION)

# imports for automatically generated classes from antlr
from prov.serializers.antlr_grammars.PROV_NVisitor import PROV_NVisitor
from prov.serializers.antlr_grammars.PROV_NParser import PROV_NParser
from prov.serializers.antlr_grammars.PROV_NLexer import PROV_NLexer

# codecs is used to generate a utf-8 string from bytesIO inputs
import codecs
# parsing of dates
import dateutil.parser
# TODO: used for debug outputs, remove at the end
from pprint import pprint
import pdb

class ProvNAntlrVisitor(PROV_NVisitor):
    """
    An extension of the automatically generated PROV_NListener, based
    on the PROV-N antlr4 grammar provided by @TomasKulhanek on GitHub
    `PROV-N grammar <https://github.com/antlr/grammars-v4/blob/master/prov-n/examples/example4.provn>`_

    For the most part, the class overrides methods automatically
    generated by antlr4 in PROV_NListener.py

    """

    def visitDocument(self, ctx):
        document = ProvDocument()
        self._doc = document

        # retrieve the namespaces as a list of prefx, iri_ref tuples (both as strings)
        namespaceDeclarations = ctx.namespaceDeclarations()
        if namespaceDeclarations is not None:
            namespaces = self.visitNamespaceDeclarations(namespaceDeclarations)
            for ns in namespaces:
                document.add_namespace(ns[0], ns[1])

        expression = ctx.expression()

        for exp in expression:
            #TODO: debug output
            print("checking expression: {}".format(exp.getText()))
            # TODO: do i need rec?
            rec = self.visitExpression(exp)

        #TODO: debug output
        print(document.get_provn())
        return document

    def visitNamespaceDeclarations(self, ctx):
        """ Visit the namespaces and retrieve them as PREFX, IRI_REF tuples in a list.
        """
        namespaces = []
        #defNsDeclaration = ctx.defaultNamespaceDeclaration()
        #if defNsDeclaration is not None:
        #    self.visitDefaultNamespaceDeclaration(defNsDeclaration)

        nsDeclaration = ctx.namespaceDeclaration()
        if nsDeclaration is not None:
            for ns in nsDeclaration:
                namespaces.append(self.visitNamespaceDeclaration(ns))

        return namespaces

    def visitDefaultNamespaceDeclaration(self, ctx):
        # TODO: most certainly, there is something more to do here
        return None
    
    def visitNamespaceDeclaration(self, ctx):
        """ Retrieve the prefix (PREFX) and the uri (IRI_REF) from a namespace context, return them as a tuple (PREFX, IRI_REF)
        """
        
        prefx = ctx.PREFX().getText()
        iri_ref = ctx.namespace().IRI_REF().getText()
        # clean brackets if necessary
        if iri_ref[:1] == '<' and iri_ref[-1:] == '>':
            iri_ref = iri_ref[1:-1]
        return (prefx, iri_ref)
    
    def visitEntityExpression(self, ctx):
        """ Retrieves an entity created using the reference to _doc
        """

        identifier = self.visitIdentifier(ctx.identifier())
        entity = self._doc.entity(identifier)

        self.add_attributes_to(entity, ctx)

        return entity

    def visitActivityExpression(self, ctx):
        """ Retrieves an activity created using the reference to _doc
        """

        identifier = self.visitIdentifier(ctx.identifier())
        activity = self._doc.activity(identifier)
        activity.set_time(self.visitTimeOrMarker(ctx.timeOrMarker(0)), self.visitTimeOrMarker(ctx.timeOrMarker(1)))

        self.add_attributes_to(activity, ctx)

        return activity

    def visitAgentExpression(self, ctx):
        """ Retrieves an agent creted using the reference to _doc
        """

        identifier = self.visitIdentifier(ctx.identifier())
        agent = self._doc.agent(identifier)

        self.add_attributes_to(agent, ctx)

        return agent

    def visitUsageExpression(self, ctx):
        """ Retrieves a usage relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        activity = self.visitChildren(ctx.aIdentifier())
        entity = self.visitChildren(ctx.eIdentifierOrMarker())
        time = self.visitTimeOrMarker(ctx.timeOrMarker())
        usage = self._doc.usage(activity, entity=entity, time=time, identifier=identifier)

        self.add_attributes_to(usage, ctx)

        return usage

    def visitCommunicationExpression(self, ctx):
        """ Retrieves a communication relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        activities = [self.visitChildren(ctx.aIdentifier(0)), self.visitChildren(ctx.aIdentifier(1))]
        
        communication = self._doc.communication(activities[0], activities[1], identifier=identifier)

        return communication

    def visitDerivationExpression(self, ctx):
        """ Retrieves a derivation relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        entities = [self.visitChildren(ctx.eIdentifier(0)), self.visitChildren(ctx.eIdentifier(1))]
        activity = self.visitChildren(ctx.aIdentifierOrMarker())
        generation = self.visitChildren(ctx.gIdentifierOrMarker())
        usage = self.visitChildren(ctx.uIdentifierOrMarker())

        derivation = self._doc.derivation(entities[0], entities[1], activity=activity, generation=generation, usage=usage, identifier=identifier)

        self.add_attributes_to(derivation, ctx)

        return derivation

    def visitAssociationExpression(self, ctx):
        """ Retrievs an association relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        activity = self.visitChildren(ctx.aIdentifier())
        agent = self.visitChildren(ctx.agIdentifierOrMarker())
        plan = self.visitChildren(ctx.eIdentifierOrMarker())
        association = self._doc.association(activity, agent=agent, plan=plan, identifier=identifier)

        self.add_attributes_to(association, ctx)

        return association

    def visitAttributionExpression(self, ctx):
        """ Retrieves an attribution relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        entity = self.visitChildren(ctx.eIdentifier())
        agent = self.visitChildren(ctx.agIdentifier())
        attribution = self._doc.attribution(entity, agent, identifier=identifier)

        self.add_attributes_to(attribution, ctx)

        return attribution

    def visitGenerationExpression(self, ctx):
        """ Retrieves a generation relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        entity = self.visitChildren(ctx.eIdentifier())
        activity = self.visitChildren(ctx.aIdentifierOrMarker())
        time = self.visitTimeOrMarker(ctx.timeOrMarker())
        generation = self._doc.generation(entity, activity=activity, time=time, identifier=identifier)

        self.add_attributes_to(generation, ctx)

        return generation

    def visitDelegationExpression(self, ctx):
        """ Retrieves a delegation relation created using the reference to _doc
        """

        identifier = self.visitOptionalIdentifier(ctx.optionalIdentifier())
        agents = [self.visitChildren(ctx.agIdentifier(0)), self.visitChildren(ctx.agIdentifier(1))]
        activity = self.visitChildren(ctx.aIdentifierOrMarker())
        delegation = self._doc.delegation(agents[0], agents[1], activity=activity, identifier=identifier)

        self.add_attributes_to(delegation, ctx)

        return delegation

    def visitIdentifier(self, ctx):
        """ Retrieves a string value for an identifier
        """

        if ctx is None:
            return None
        if ctx.PREFX() is not None:
            return ctx.PREFX().getText()
        elif ctx.QUALIFIED_NAME() is not None:
            return ctx.QUALIFIED_NAME().getText()
        return None
    
    def add_attributes_to(self, statement, ctx):
        """ Iterates through all optionalAttributeValuePairs and adds them to the attributes of statement.
        """
        attributes = self.visitOptionalAttributeValuePairs(ctx.optionalAttributeValuePairs())
        for att in attributes:
            statement.add_attributes(att)
        return statement

    def visitOptionalAttributeValuePairs(self, ctx):
        """ Gets the attribute value pairs from it child
        """
        return self.visitAttributeValuePairs(ctx.attributeValuePairs())

    def visitAttributeValuePairs(self, ctx):
        """ Creates and returns a list of all attribute value pairs that are generated as {key: value} dictionaries
        """
        allKeyVals = []
        # catch elements without attributes
        if ctx is None:
            return allKeyVals

        for keyVals in ctx.attributeValuePair():
            allKeyVals.append(self.visitAttributeValuePair(keyVals))
        return allKeyVals

    def visitAttributeValuePair(self, ctx):
        """ Returns an attribute value pair from an expression as a dictionary {attribute: value}
        """

        return {
            self.visitAttribute(ctx.attribute()): self.visitLiteral(ctx.literal())
        }

    def visitAttribute(self, ctx):
        """ As the PROV-N specification states that attribute = QUALIFIED_NAME, it can be handled equally as identifiers of records.
        """

        return self.visitIdentifier(ctx)
    
    def visitLiteral(self, ctx):
        if ctx.typedLiteral() is not None:
            return "typedLiteral"
        if ctx.convenienceNotation() is not None:
            return self.visitConvenienceNotation(ctx.convenienceNotation())
        return ""
    
    def visitConvenienceNotation(self, ctx):
        """ Retrieves values from convenience notations within attribute lists of prov records as a single value (depending on its type)
        """

        # handle string literals
        if ctx.STRING_LITERAL() is not None:
            if ctx.LANGTAG() is not None:
                return "how to parse that?"
            return self.cleanStringValues(ctx.STRING_LITERAL().getText())

        # handle int literals
        if ctx.INT_LITERAL() is not None:
            # TODO: parse as int
            return ctx.INT_LITERAL().getText()

        # handle qualified name literals
        if ctx.QUALIFIED_NAME_LITERAL() is not None:
            return self._doc.valid_qualified_name(self.cleanStringValues(ctx.QUALIFIED_NAME_LITERAL().getText()))

    def cleanStringValues(self, string):
        if string[:1] == string[-1:] and string[:1] in ["'", '"']:
            return string[1:-1]
        return string

    def visitTimeOrMarker(self, ctx):
        if ctx is None:
            return None
        return self.visitTime(ctx.time())

    def visitTime(self, ctx):
        if ctx is None:
            return None
        # TODO: possible parser exception? try to handle that gracefully
        return dateutil.parser.parse(ctx.DATETIME().getText())

    def visitOptionalIdentifier(self, ctx):
        """ gets the optional identifier
        """
        return self.visitIdentifierOrMarker(ctx.identifierOrMarker())
    
    def visitIdentifierOrMarker(self, ctx):
        """ Returns an identifier (PREFX or QUALIFIED_NAME) is supplied, otherwise return None for a marker ( '-' in PROV-N)
        """
        if ctx is None or ctx.identifier() is None:
            return None

        return self.visitIdentifier(ctx.identifier())


class ProvNSerializer(Serializer):
    """PROV-N serializer for ProvDocument

    """
    def serialize(self, stream, **kwargs):
        """
        Serializes a :class:`prov.model.ProvDocument` instance to a
        `PROV-N <http://www.w3.org/TR/prov-n/>`_.

        :param stream: Where to save the output.
        """
        provn_content = self.document.get_provn()
        if isinstance(stream, io.BytesIO):
            provn_content = provn_content.encode('utf-8')
        stream.write(provn_content)

    def deserialize(self, stream, **kwargs):
        """
        Deserializes from a `PROV-N <https://www.w3.org/TR/prov-n/>`_
        representation to a :class:`~prov.model.ProvDocument` instance.

        :param stream: Input data.
        """
        if isinstance(stream, io.BytesIO):
            stream = codecs.decode(stream.getvalue(), encoding='utf-8')
            stream = InputStream(stream)
        if isinstance(stream, io.StringIO):
            stream = InputStream(stream.getvalue())
        lexer = PROV_NLexer(stream)
        tokenStream = CommonTokenStream(lexer)
        parser = PROV_NParser(tokenStream)
        tree = parser.document()
        visitor = ProvNAntlrVisitor()
        return visitor.visit(tree)
