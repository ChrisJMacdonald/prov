from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

__author__ = 'Trung Dong Huynh'
__email__ = 'trungdong@donggiang.com'
__contributor__ = 'Marcel Parciak'

import io
import logging
logger = logging.getLogger(__name__)

# import needed antlr4 elements, CommonTokenStream will tokenize the input PROV-N document
from antlr4 import CommonTokenStream
# ParseTreeWalker allows to walk through the parsed tokens
from antlr4 import ParseTreeWalker
# InputStream is needed to transform the input stream from BytesIO to a InputStream explicitly
from antlr4 import InputStream

from prov.model import ProvDocument
from prov.serializers import Serializer
from prov.constants import (
    PROV, PROV_ID_ATTRIBUTES_MAP, PROV_N_MAP, PROV_BASE_CLS, XSD_QNAME, PROV_ENTITY,
    PROV_END, PROV_START, PROV_USAGE, PROV_GENERATION, PROV_DERIVATION, PROV_INVALIDATION,
    PROV_ALTERNATE, PROV_MENTION, PROV_DELEGATION, PROV_ACTIVITY, PROV_ATTR_STARTTIME,
    PROV_ATTR_ENDTIME, PROV_LOCATION, PROV_ATTR_TIME, PROV_ROLE, PROV_COMMUNICATION,
    PROV_ATTR_INFORMANT, PROV_ATTR_RESPONSIBLE, PROV_ATTR_TRIGGER, PROV_ATTR_ENDER,
    PROV_ATTR_STARTER, PROV_ATTR_USED_ENTITY, PROV_ASSOCIATION)

# imports for automatically generated classes from antlr
from prov.serializers.antlr_grammars.PROV_NVisitor import PROV_NVisitor
from prov.serializers.antlr_grammars.PROV_NParser import PROV_NParser
from prov.serializers.antlr_grammars.PROV_NLexer import PROV_NLexer

# codecs is used to generate a utf-8 string from bytesIO inputs
import codecs
# TODO: used for debug outputs, remove at the end
from pprint import pprint
import pdb

class ProvNAntlrVisitor(PROV_NVisitor):
    """
    An extension of the automatically generated PROV_NListener, based
    on the PROV-N antlr4 grammar provided by @TomasKulhanek on GitHub
    `PROV-N grammar <https://github.com/antlr/grammars-v4/blob/master/prov-n/examples/example4.provn>`_

    For the most part, the class overrides methods automatically
    generated by antlr4 in PROV_NListener.py

    """

    def visitDocument(self, ctx):
        document = ProvDocument()
        self._doc = document

        # retrieve the namespaces as a list of prefx, iri_ref tuples (both as strings)
        namespaceDeclarations = ctx.namespaceDeclarations()
        if namespaceDeclarations is not None:
            namespaces = self.visitNamespaceDeclarations(namespaceDeclarations)
            for ns in namespaces:
                document.add_namespace(ns[0], ns[1])

        expression = ctx.expression()

        for exp in expression:
            # TODO: do i need that?
            rec = self.visitExpression(exp)

        print(document.get_provn())
        return document

    def visitNamespaceDeclarations(self, ctx):
        """ Visit the namespaces and retrieve them as PREFX, IRI_REF tuples in a list.
        """
        namespaces = []
        #defNsDeclaration = ctx.defaultNamespaceDeclaration()
        #if defNsDeclaration is not None:
        #    self.visitDefaultNamespaceDeclaration(defNsDeclaration)

        nsDeclaration = ctx.namespaceDeclaration()
        if nsDeclaration is not None:
            for ns in nsDeclaration:
                namespaces.append(self.visitNamespaceDeclaration(ns))

        return namespaces

    def visitDefaultNamespaceDeclaration(self, ctx):
        print(ctx.IRI_REF())
        return None
    
    def visitNamespaceDeclaration(self, ctx):
        """ Retrieve the prefix (PREFX) and the uri (IRI_REF) from a namespace context, return them as a tuple (PREFX, IRI_REF)
        """
        
        prefx = ctx.PREFX().getText()
        iri_ref = ctx.namespace().IRI_REF().getText()
        # clean brackets if necessary
        if iri_ref[:1] == '<' and iri_ref[-1:] == '>':
            iri_ref = iri_ref[1:-1]
        return (prefx, iri_ref)
    
    def visitExpression(self, ctx):
        """ Retrieves an expression in the form to create a new record: record_type (see :py:const:`PROV_REC_CLS`), an identifier and a dict of attributes.
        """

        if ctx.entityExpression() is not None:
            return self.visitEntityExpression(ctx.entityExpression())

    def visitEntityExpression(self, ctx):
        """ Retrieves an entity in a triplet form: record_type (see :py:const:`PROV_REC_CLS`), an identifier and a dict of attributes
        """

        identifier = self.visitIdentifier(ctx.identifier())
        entity = self._doc.entity(identifier)

        optionalAttributes = ctx.optionalAttributeValuePairs()
        if optionalAttributes is not None:
            attValPairsContext = optionalAttributes.attributeValuePairs()
            if attValPairsContext is not None:
                for keyVals in attValPairsContext.attributeValuePair():
                    attrPair = self.visitAttributeValuePair(keyVals)
                    entity.add_attributes(attrPair)

        return entity

    def visitIdentifier(self, ctx):
        """ Retrieves a string value for an identifier
        """

        if ctx.PREFX() is not None:
            return ctx.PREFX().getText()
        else:
            return ctx.QUALIFIED_NAME().getText()
    
    def visitAttributeValuePair(self, ctx):
        """ Returns an attribute value pair from an expression as a dictionary {attribute: value}
        """

        return {
            self.visitAttribute(ctx.attribute()): self.visitLiteral(ctx.literal())
        }

    def visitAttribute(self, ctx):
        """ As the PROV-N specification states that attribute = QUALIFIED_NAME, it can be handled equally as identifiers of records.
        """

        return self.visitIdentifier(ctx)
    
    def visitLiteral(self, ctx):
        if ctx.typedLiteral() is not None:
            return "typedLiteral"
        if ctx.convenienceNotation() is not None:
            return self.visitConvenienceNotation(ctx.convenienceNotation())
        return ""
    
    def visitConvenienceNotation(self, ctx):
        """ Retrieves values from convenience notations within attribute lists of prov records as a single value (depending on its type)
        """

        # handle string literals
        if ctx.STRING_LITERAL() is not None:
            if ctx.LANGTAG() is not None:
                return "how to parse that?"
            return self.cleanStringValues(ctx.STRING_LITERAL().getText())

        # handle int literals
        if ctx.INT_LITERAL() is not None:
            # TODO: parse as int
            return ctx.INT_LITERAL().getText()

        # handle qualified name literals
        if ctx.QUALIFIED_NAME_LITERAL() is not None:
            return self._doc.valid_qualified_name(self.cleanStringValues(ctx.QUALIFIED_NAME_LITERAL().getText()))

    def cleanStringValues(self, string):
        if string[:1] == string[-1:] and string[:1] in ["'", '"']:
            return string[1:-1]
        return string


class ProvNSerializer(Serializer):
    """PROV-N serializer for ProvDocument

    """
    def serialize(self, stream, **kwargs):
        """
        Serializes a :class:`prov.model.ProvDocument` instance to a
        `PROV-N <http://www.w3.org/TR/prov-n/>`_.

        :param stream: Where to save the output.
        """
        provn_content = self.document.get_provn()
        if isinstance(stream, io.BytesIO):
            provn_content = provn_content.encode('utf-8')
        stream.write(provn_content)

    def deserialize(self, stream, **kwargs):
        """
        Deserializes from a `PROV-N <https://www.w3.org/TR/prov-n/>`_
        representation to a :class:`~prov.model.ProvDocument` instance.

        :param stream: Input data.
        """
        if isinstance(stream, io.BytesIO):
            stream = codecs.decode(stream.getvalue(), encoding='utf-8')
            stream = InputStream(stream)
        if isinstance(stream, io.StringIO):
            stream = InputStream(stream.getvalue())
        lexer = PROV_NLexer(stream)
        tokenStream = CommonTokenStream(lexer)
        parser = PROV_NParser(tokenStream)
        tree = parser.document()
        visitor = ProvNAntlrVisitor()
        return visitor.visit(tree)