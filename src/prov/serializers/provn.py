from __future__ import absolute_import, division, print_function, unicode_literals

__author__ = "Trung Dong Huynh"
__email__ = "trungdong@donggiang.com"

import io

# import needed antlr4 elements, CommonTokenStream will tokenize the input PROV-N document
from antlr4 import CommonTokenStream
# ParseTreeWalker allows to walk through the parsed tokens
from antlr4 import ParseTreeWalker
# InputStream is needed to transform the input stream from BytesIO to a InputStream explicitly
from antlr4 import InputStream

import prov.model as pm
from prov.serializers import Serializer
from prov.constants import (
    PROV, PROV_ID_ATTRIBUTES_MAP, PROV_N_MAP, PROV_BASE_CLS, XSD_QNAME, PROV_ENTITY,
    PROV_END, PROV_START, PROV_USAGE, PROV_GENERATION, PROV_DERIVATION, PROV_INVALIDATION,
    PROV_ALTERNATE, PROV_MENTION, PROV_DELEGATION, PROV_ACTIVITY, PROV_ATTR_STARTTIME,
    PROV_ATTR_ENDTIME, PROV_LOCATION, PROV_ATTR_TIME, PROV_ROLE, PROV_COMMUNICATION,
    PROV_ATTR_INFORMANT, PROV_ATTR_RESPONSIBLE, PROV_ATTR_TRIGGER, PROV_ATTR_ENDER,
    PROV_ATTR_STARTER, PROV_ATTR_USED_ENTITY, PROV_ASSOCIATION)

# imports for automatically generated classes from antlr
from prov.serializers.antlr_grammars.PROV_NVisitor import PROV_NVisitor
from prov.serializers.antlr_grammars.PROV_NParser import PROV_NParser
from prov.serializers.antlr_grammars.PROV_NLexer import PROV_NLexer

# codecs is used to generate a utf-8 string from bytesIO inputs
import codecs
# parsing of dates
import dateutil.parser
# TODO: used for debug outputs, remove at the end
from pprint import pprint
import random
import pdb

class ProvNAntlrVisitor(PROV_NVisitor):
    """
    An extension of the automatically generated PROV_NListener, based
    on the PROV-N antlr4 grammar provided by @TomasKulhanek on GitHub
    `PROV-N grammar <https://github.com/antlr/grammars-v4/blob/master/prov-n/examples/example4.provn>`_

    For the most part, the class overrides methods automatically
    generated by antlr4 in PROV_NListener.py

    """

    def visitDocument(self, ctx:PROV_NParser.DocumentContext):
        """
        """
        document = pm.ProvDocument()
        self._doc = document
        self.parseContainer(document, ctx)

        # after the expressions, parse the bundles
        bundles = ctx.bundle()
        for bun in bundles:
            self.visitBundle(bun)

        print("one document", document.get_provn())
        return document

    def visitBundle(self, ctx:PROV_NParser.BundleContext):
        """
        """
        bundle = pm.ProvBundle(document=self._doc)
        parentDoc = self._doc
        self._doc = bundle
        self.parseContainer(bundle, ctx)
        self._doc = parentDoc

        hackId = self.visitIdentifier(ctx.identifier())
        if hackId is None:
            hackId = 'ex:hackyIdIInvented{}'.format(random.randint(0, 1024))
            print("An ID is hacked: {}".format(hackId))

        print("The ID: {}".format(hackid))
        self._doc.add_bundle(bundle, identifier=hackId)
        
    def parseContainer(self, document, ctx):
        """ Really cool description
        """

        # retrieve the namespaces as a list of prefx, iri_ref tuples (both as strings)
        namespaceDeclarations = ctx.namespaceDeclarations()
        if namespaceDeclarations is not None:

            # get the default namespace, if available
            defNamespace = self.visitDefaultNamespaceDeclaration(namespaceDeclarations)
            if defNamespace is not None:
                document.set_default_namespace(defNamespace)

            namespaces = self.visitNamespaceDeclarations(namespaceDeclarations)
            for ns in namespaces:
                document.add_namespace(ns[0], ns[1])

        # handle all expressions
        expression = ctx.expression()
        for exp in expression:
            self.visitExpression(exp)

    def visitNamespaceDeclarations(self, ctx):
        """ Visit the namespaces and retrieve them as PREFX, IRI_REF tuples in a list.
        """
        namespaces = []

        nsDeclaration = ctx.namespaceDeclaration()
        if nsDeclaration is not None:
            for ns in nsDeclaration:
                namespaces.append(self.visitNamespaceDeclaration(ns))

        return namespaces

    def visitDefaultNamespaceDeclaration(self, ctx):
        """ TODO: text
        """

        defNs = ctx.defaultNamespaceDeclaration()
        if defNs is not None:
            defNsStr = defNs.IRI_REF().getText()
            if defNsStr[:1] == '<' and defNsStr[-1:] == '>':
                return defNsStr[1:-1]
            return defNsStr
        return None
    
    def visitNamespaceDeclaration(self, ctx):
        """ Retrieve the prefix (PREFX) and the uri (IRI_REF) from a namespace context, return them as a tuple (PREFX, IRI_REF)
        """
        
        prefx = ctx.PREFX().getText()
        iri_ref = ctx.namespace().IRI_REF().getText()
        # clean brackets if necessary
        if iri_ref[:1] == '<' and iri_ref[-1:] == '>':
            iri_ref = iri_ref[1:-1]
        return (prefx, iri_ref)
    
    def visitEntityExpression(self, ctx):
        """ Retrieves an entity created using the reference to _doc
        """

        return self.createStatementFromVisit("entity", { "identifier": ctx.identifier() }, ctx)

    def visitActivityExpression(self, ctx):
        """ Retrieves an activity created using the reference to _doc
        """

        return self.createStatementFromVisit("activity", {
                "identifier": ctx.identifier(),
                "startTime": ctx.timeOrMarker(0),
                "endTime": ctx.timeOrMarker(1)
            }, ctx)

    def visitAgentExpression(self, ctx):
        """ Retrieves an agent creted using the reference to _doc
        """

        return self.createStatementFromVisit("agent", { "identifier": ctx.identifier() }, ctx)

    def visitUsageExpression(self, ctx):
        """ Retrieves a usage relation created using the reference to _doc
        """

        return self.createStatementFromVisit("usage", {
                "activity": ctx.aIdentifier(),
                "entity": ctx.eIdentifierOrMarker(),
                "time": ctx.timeOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitCommunicationExpression(self, ctx):
        """ Retrieves a communication relation created using the reference to _doc
        """

        return self.createStatementFromVisit("communication", {
                "informed": ctx.aIdentifier(0),
                "informant": ctx.aIdentifier(1),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitDerivationExpression(self, ctx):
        """ Retrieves a derivation relation created using the reference to _doc
        """

        return self.createStatementFromVisit("derivation", {
                "generatedEntity": ctx.eIdentifier(0),
                "usedEntity": ctx.eIdentifier(1),
                "activity": ctx.aIdentifierOrMarker(),
                "generation": ctx.gIdentifierOrMarker(),
                "usage": ctx.uIdentifierOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitAssociationExpression(self, ctx):
        """ Retrievs an association relation created using the reference to _doc
        """

        return self.createStatementFromVisit("association", {
                "activity": ctx.aIdentifier(),
                "agent": ctx.agIdentifierOrMarker(),
                "plan": ctx.eIdentifierOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitAttributionExpression(self, ctx):
        """ Retrieves an attribution relation created using the reference to _doc
        """

        return self.createStatementFromVisit("attribution", {
                "identifier": ctx.optionalIdentifier(),
                "entity": ctx.eIdentifier(),
                "agent": ctx.agIdentifier()
            }, ctx)

    def visitGenerationExpression(self, ctx):
        """ Retrieves a generation relation created using the reference to _doc
        """

        return self.createStatementFromVisit("generation", {
                "entity": ctx.eIdentifier(),
                "activity": ctx.aIdentifierOrMarker(),
                "time": ctx.timeOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitDelegationExpression(self, ctx):
        """ Retrieves a delegation relation created using the reference to _doc
        """

        return self.createStatementFromVisit("delegation", {
                "delegate": ctx.agIdentifier(0),
                "responsible": ctx.agIdentifier(1),
                "activity": ctx.aIdentifierOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitStartExpression(self, ctx):
        """ TODO: text
        """

        return self.createStatementFromVisit("start", {
                "activity": ctx.aIdentifier(),
                "trigger": ctx.eIdentifierOrMarker(),
                "starter": ctx.aIdentifierOrMarker(),
                "time": ctx.timeOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitEndExpression(self, ctx):
        """ TODO: text
        """

        return self.createStatementFromVisit("end", {
                "activity": ctx.aIdentifier(),
                "trigger": ctx.eIdentifierOrMarker(),
                "ender": ctx.aIdentifierOrMarker(),
                "time": ctx.timeOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitInvalidationExpression(self, ctx):
        """ TODO: text
        """

        return self.createStatementFromVisit("invalidation", {
                "entity": ctx.eIdentifier(),
                "activity": ctx.aIdentifierOrMarker(),
                "time": ctx.timeOrMarker(),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitSpecializationExpression(self, ctx):
        """ TODO: text
        """

        return self.createStatementFromVisit("specialization", {
                "specificEntity": ctx.eIdentifier(0),
                "generalEntity": ctx.eIdentifier(1)
            }, ctx)

    def visitMembershipExpression(self, ctx):
        """ TODO: text
        """

        return self.createStatementFromVisit("membership", {
                "collection": ctx.cIdentifier(),
                "entity": ctx.eIdentifier()
            }, ctx)

    def visitInfluenceExpression(self, ctx):
        """ TODO: text
        """

        return self.createStatementFromVisit("influence", {
                "influencee": ctx.eIdentifier(0),
                "influencer": ctx.eIdentifier(1),
                "identifier": ctx.optionalIdentifier()
            }, ctx)

    def visitAlternateExpression(self, ctx:PROV_NParser.AlternateExpressionContext):
        """ TODO: text
        """

        return self.createStatementFromVisit("alternate", {
                "alternate1": ctx.eIdentifier(0),
                "alternate2": ctx.eIdentifier(1)
            }, ctx)

    def visitIdentifier(self, ctx):
        """ Retrieves a string value for an identifier
        """

        if ctx is None:
            return None
        if ctx.PREFX() is not None:
            return ctx.PREFX().getText()
        elif ctx.QUALIFIED_NAME() is not None:
            return ctx.QUALIFIED_NAME().getText()
        return None

    def visitOptionalIdentifier(self, ctx):
        """ gets the optional identifier
        """
        return self.visitIdentifierOrMarker(ctx.identifierOrMarker())
    
    def visitIdentifierOrMarker(self, ctx):
        """ Returns an identifier (PREFX or QUALIFIED_NAME) is supplied, otherwise return None for a marker ( '-' in PROV-N)
        """
        if ctx is None or ctx.identifier() is None:
            return None

        return self.visitIdentifier(ctx.identifier())

    def visitTimeOrMarker(self, ctx):
        if ctx is None:
            return None
        return self.visitTime(ctx.time())

    def visitTime(self, ctx):
        if ctx is None:
            return None
        # TODO: possible parser exception? try to handle that gracefully
        return dateutil.parser.parse(ctx.DATETIME().getText())

    def visitOptionalAttributeValuePairs(self, ctx):
        """ Gets the attribute value pairs from it child
        """

        return self.visitAttributeValuePairs(ctx.attributeValuePairs())

    def visitAttributeValuePairs(self, ctx):
        """ Creates and returns a list of all attribute value pairs that are generated as {key: value} dictionaries
        """

        allKeyVals = []
        # catch elements without attributes
        if ctx is None:
            return allKeyVals

        for keyVals in ctx.attributeValuePair():
            allKeyVals.append(self.visitAttributeValuePair(keyVals))
        return allKeyVals

    def visitAttributeValuePair(self, ctx):
        """ Returns an attribute value pair from an expression as a dictionary {attribute: value}
        """

        return {
            self.visitAttribute(ctx.attribute()): self.visitChildren(ctx.literal())
        }

    def visitAttribute(self, ctx):
        """ As the PROV-N specification states that attribute = QUALIFIED_NAME, it can be handled equally as identifiers of records.
        """

        return self.visitIdentifier(ctx)

    def visitTypedLiteral(self, ctx):
        """ Returns a typed literal, based on the cleaned string value and the qualified name datatype
        """

        if ctx.STRING_LITERAL() is None or ctx.datatype() is None:
            return None
        stringLiteral = self.cleanStringValues(ctx.STRING_LITERAL().getText())
        datatype = self.cleanStringValues(ctx.datatype().getText())
        # TODO: formalize this in another way, there has to be one
        if datatype == 'xsd:float':
            return float(stringLiteral)
        elif datatype == 'xsd:int':
            return int(stringLiteral)
        elif datatype == 'xsd:string':
            return stringLiteral
        elif datatype == 'xsd:double':
            return float(stringLiteral)
        else:
            datatype = self._doc.valid_qualified_name(self.cleanStringValues(ctx.datatype().getText()))
            return pm.Literal(stringLiteral, datatype=datatype)
    
    def visitConvenienceNotation(self, ctx):
        """ Retrieves values from convenience notations within attribute lists of prov records as a single value (depending on its type)
        """

        # handle string literals
        if ctx.STRING_LITERAL() is not None:
            if ctx.LANGTAG() is not None:
                # The LANGTAG-getText value includes the @ character, which is not needed
                return pm.Literal(self.cleanStringValues(ctx.STRING_LITERAL().getText()), langtag=ctx.LANGTAG().getText()[1:])
            return self.cleanStringValues(ctx.STRING_LITERAL().getText())

        # handle int literals
        if ctx.INT_LITERAL() is not None:
            return int(ctx.INT_LITERAL().getText())

        # handle qualified name literals
        if ctx.QUALIFIED_NAME_LITERAL() is not None:
            return self._doc.valid_qualified_name(self.cleanStringValues(ctx.QUALIFIED_NAME_LITERAL().getText()))

    def cleanStringValues(self, string):
        """ Cleans special characters from String typed values.
        This method will clean surrounding quotation marks from a String value. This way, they will be handled as python string values without depending on the quotation marks that are used in the PROV-N document. If no quotations surround the string, no modification will be made.
        """

        if string[:3] == string[-3:] and string[:3] in ["'''", '"""']:
            return string[3:-3]
        if string[:1] == string[-1:] and string[:1] in ["'", '"']:
            return string[1:-1]
        return string

    def createStatementFromVisit(self, stmt_name, args, ctx):
        """ Creates a prov statement from the parameters supplied.
        TODO: make that a longer description
        """
        if hasattr( self._doc, stmt_name ):
            for prop, prop_context in args.items():
                if isinstance(prop_context, PROV_NParser.TimeOrMarkerContext):
                    args[prop] = self.visitTimeOrMarker(prop_context)
                elif isinstance(prop_context, PROV_NParser.OptionalIdentifierContext):
                    args[prop] = self.visitOptionalIdentifier(prop_context)
                elif isinstance(prop_context, PROV_NParser.IdentifierContext):
                    args[prop] = self.visitIdentifier(prop_context)
                else:
                    args[prop] = self.visitChildren(prop_context)

            method = getattr( self._doc, stmt_name)
            statement = method(**args)
            if hasattr(ctx, "optionalAttributeValuePairs"):
                self.add_attributes_to(statement, ctx)

            return statement
        else:
            return None
    
    def add_attributes_to(self, statement, ctx):
        """ Iterates through all optionalAttributeValuePairs and adds them to the attributes of statement.
        """
        attributes = self.visitOptionalAttributeValuePairs(ctx.optionalAttributeValuePairs())
        for att in attributes:
            statement.add_attributes(att)
        return statement


class ProvNSerializer(Serializer):
    """PROV-N serializer for ProvDocument

    """

    def serialize(self, stream, **kwargs):
        """
        Serializes a :class:`prov.model.ProvDocument` instance to a
        `PROV-N <http://www.w3.org/TR/prov-n/>`_.

        :param stream: Where to save the output.
        """
        provn_content = self.document.get_provn()
        if not isinstance(stream, io.TextIOBase):
            provn_content = provn_content.encode("utf-8")
        stream.write(provn_content)

    def deserialize(self, stream, **kwargs):
        """
        Deserializes from a `PROV-N <https://www.w3.org/TR/prov-n/>`_
        representation to a :class:`~prov.model.ProvDocument` instance.

        :param stream: Input data.
        """
        if isinstance(stream, io.BytesIO):
            stream = codecs.decode(stream.getvalue(), encoding='utf-8')
            stream = InputStream(stream)
        if isinstance(stream, io.StringIO):
            stream = InputStream(stream.getvalue())
        lexer = PROV_NLexer(stream)
        tokenStream = CommonTokenStream(lexer)
        parser = PROV_NParser(tokenStream)
        tree = parser.document()
        visitor = ProvNAntlrVisitor()
        return visitor.visit(tree)
